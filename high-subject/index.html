<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>高级级前端面试题</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        html,body{
            background: #f0f0f0;
            color: #333;
            font: 400 12px/1.4 "Lantinghei SC","Hiragino Sans GB",'Microsoft YaHei',Helvetica,arial,simsun,sans-serif;
        }
        .wrapper{
            width: 900px;
            margin: 30px auto;
            padding: 20px;;
            background: #fff;
            -webkit-border-radius: 10px;
            -moz-border-radius: 10px;
            border-radius: 10px;;
        }
        .wrapper h1{
            color: #245580;
            text-align: center;
        }
        .wrapper h2{
            font-size: 22px;
            color:#2e2e2e;
            margin: 20px 0 10px 0;
            border-bottom: 2px solid #eee;
        }
        .wrapper h3{
            font-size: 18px;
            color: #0055ff;
            margin: 10px 0 5px 0;
        }
        .wrapper p{
            color: #333;
            margin: 0 10px;
            font-size: 17px;
            line-height: 23px;
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-line;
            word-wrap:normal;
            word-break:normal;
        }
        a{
            color: #0000ff;
        }
        a:hover{
            text-decoration: none;
        }
        span.red{
            color: #c21b1b;
        }
        img{
            width: auto;
            margin: 10px;
        }
        code{
            color: #333;
            font-weight: 300;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="wrapper">
        <h1>前端开发知识点：</h1>
        <h3>对WEB标准以及W3C的理解与认识</h3>
        <p>HTML&CSS：
            对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
            HTML5、CSS3、Flexbox

            JavaScript：
            数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
            DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

            其他：
            移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力
        </p>
        <h3>作为一名前端工程师，无论工作年头长短都应该掌握的知识点：</h3>
        <p>1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。
            2、DOM操作 ——如何添加、移除、移动、复制、创建和查找节点等。
            3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。
            4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。
            5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。
            6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型
            7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们
            8、浮动元素 ——怎么使用它们、它们有什么问题以及怎么解决这些问题。
            9、HTML与XHTML ——二者有什么区别，你觉得应该使用哪一个并说出理由。
            10、JSON —— 作用、用途、设计结构。
        </p>
        <h2>HTML</h2>
        <h3>1.Doctype作用？标准模式与兼容模式各有什么区别?</h3>
        <p>（1）、<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。

            （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。
        </p>
        <h3>2.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h3>
        <p> HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；

            而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
        <h3>3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3>
        <p>首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

            （1）行内元素有：a b span img input select strong（强调的语气）
            （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
            （3）常见的空元素：
            &lt;br&gt;  &lt;hr&gt; &lt;img&gt;  &lt;input&gt;  &lt;link&gt;  &lt;meta&gt;
        鲜为人知的是：
            &lt;area&gt;  &lt;base&gt;  &lt;col&gt;  &lt;command&gt; &lt;embed&gt;  &lt;keygen&gt;  &lt;param&gt;  &lt;source&gt;  &lt;track&gt;  &lt;wbr&gt;

        不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异
        参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</p>
        <h3>4.页面导入样式时，使用link和@import有什么区别？</h3>
        <p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;

            （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;

            （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
        <h3>5.介绍一下你对浏览器内核的理解？</h3>
        <p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
            渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

            JS引擎则：解析和执行javascript来实现网页的动态效果。

            最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

            详细文章：<a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank">浏览器内核的解析和对比</a></p>
        <h3>6.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</h3>
        <p>* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
            绘画 canvas;
            用于媒介回放的 video 和 audio 元素;
            本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
            sessionStorage 的数据在浏览器关闭后自动删除;
            语意化更好的内容元素，比如 article、footer、header、nav、section;
            表单控件，calendar、date、time、email、url、search;
            新的技术webworker, websocket, Geolocation;

            移除的元素：
            纯表现的元素：basefont，big，center，font, s，strike，tt，u;
            对可用性产生负面影响的元素：frame，frameset，noframes；

            * 支持HTML5新标签：
            IE8/IE7/IE6支持通过document.createElement方法产生的标签，
            可以利用这一特性让这些浏览器支持HTML5新标签，
            浏览器支持新标签后，还需要添加标签默认的样式。

            当然也可以直接使用成熟的框架、比如html5shim;
            &lt;!--[if lt IE 9]&gt;
            &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
            &lt;![endif]--&gt;
        </p>
        <h3>7.简述一下你对<span class="red">HTML语义化</span>的理解？</h3>
        <p>用正确的标签做正确的事情。
            html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
            即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
            搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
            使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
        <h3>8.HTML5的<span class="red">离线储存</span>怎么使用，工作原理能不能解释一下？</h3>
        <p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
            原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

            如何使用：
            1、页面头部像下面一样加入一个manifest的属性；
            &lt;html manifest=&quot;test.manifest&quot;&gt;
            2、在cache.manifest文件的编写离线存储的资源；
            CACHE MANIFEST
            #v0.11
            CACHE:
            js/app.js
            css/style.css
            NETWORK:
            resourse/logo.png
            FALLBACK:
            / /offline.html
            3、在离线状态时，操作window.applicationCache进行需求实现。
            <a href="http://www.cnblogs.com/xqhppt/p/4157862.html" target="_blank">离线储存相关教程</a>
            <a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/" target="">详细教程</a>
            <a href="https://segmentfault.com/a/1190000000732617" target="_blank">有趣的HTML5：离线存储</a>
        </p>
        <h3>9.请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3>
        <p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
            cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
            sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

            存储大小：
            cookie数据大小不能超过4k。
            sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

            有期时间：
            localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
            sessionStorage  数据在当前浏览器窗口关闭后自动删除。
            cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
        <h3>10.iframe有那些缺点？</h3>
        <p>*iframe会阻塞主页面的Onload事件；
            *搜索引擎的检索程序无法解读这种页面，不利于SEO;

            *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

            使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
            动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
        <h3>11.如何实现浏览器内多个标签页之间的通信? (阿里)</h3>
        <p>WebSocket、SharedWorker；
            也可以调用localstorge、cookies等本地存储方式；

            localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
            我们通过监听事件，控制它的值来进行页面信息通信；
            注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</p>
        <h3>12.webSocket如何兼容低浏览器？(阿里)</h3>
        <p>Adobe Flash Socket 、
            ActiveX HTMLFile (IE) 、
            基于 multipart 编码发送 XHR 、
            基于长轮询的 XHR
            <span class="red"> *不懂百度一下</span>
        </p>
        <h3>13.<span class="red">页面可见性</span>（Page Visibility API） 可以有哪些用途？</h3>
        <p>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
            在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p>
        <h3>14.实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3>
        <p>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</p>
        <h3>15.title与h1的区别、b与strong的区别、i与em的区别？</h3>
        <p>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；

            strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。

            i内容展示为斜体，em表示强调的文本；

            Physical Style Elements -- <span class="red">自然样式标签</span>
            b, i, u, s, pre
            Semantic Style Elements -- <span class="red">语义样式标签</span>
            strong, em, ins, del, code
            应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p>

        <h2>CSS</h2>
        <h3>1.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3>
        <p>（1）有两种， IE 盒子模型、W3C 盒子模型；
            （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；
            （3）<span class="red">区别</span>： IE的content部分把 border 和 padding计算了进去;</p>
        <h3>2.CSS选择符有哪些？哪些属性可以继承？</h3>
        <p>*   1.id选择器（ # myid）
                2.类选择器（.myclassname）
                3.标签选择器（div, h1, p）
                4.相邻选择器（h1 + p）
                5.子选择器（ul > li）
                6.后代选择器（li a）
                7.通配符选择器（ * ）
                8.属性选择器（a[rel = "external"]）
                9.伪类选择器（a:hover, li:nth-child）

            *   <span class="red">可继承的样式</span>： font-size font-family color, UL LI DL DD DT;

            *   <span class="red">不可继承的样式</span>：border padding margin width height ;</p>
        <h3>3.CSS优先级算法如何计算？</h3>
        <p>*   优先级就近原则，同权重情况下样式定义最近者为准;
            *   载入样式以最后载入的定位为准;

            优先级为:
            同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。
            !important &gt;  id &gt; class &gt; tag
            important 比 内联优先级高</p>
        <h3>4.<span class="red">flexbox</span>布局水平垂直居中</h3>
        <p>利用 flex 布局
            实际使用时应考虑兼容性

            .container {
            display: flex;
            align-items: center;        /* 垂直居中 */
            justify-content: center;    /* 水平居中 */

            }
            .container div {
            width: 100px;
            height: 100px;
            background-color: pink;     /* 方便看效果 */
            }</p>
        <h3>5.CSS3新增伪类有那些？</h3>
        <p>  举例：
            p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
            p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
            p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
            p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
            p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

            :after          在元素之前添加内容,也可以用来做清除浮动。
            :before         在元素之后添加内容
            :enabled
            :disabled       控制表单控件的禁用状态。
            :checked        单选框或复选框被选中</p>
        <h3>6.position的值relative和absolute定位原点是？</h3>
        <p>  absolute
            生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
            fixed （老IE不支持）
            生成绝对定位的元素，相对于浏览器窗口进行定位。
            relative
            生成相对定位的元素，相对于其正常位置进行定位。
            static
            默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
            inherit
            规定从父元素继承 position 属性的值。</p>
        <h3>7.CSS3有哪些新特性？</h3>
        <p>  新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）
            圆角            （border-radius:8px）
            多列布局      （multi-column layout）
            阴影和反射   （Shadow\Reflect）
            文字特效      （text-shadow、）
            文字渲染      （Text-decoration）
            <span class="red">线性渐变</span>      （gradient）
            旋转            （transform）
            缩放,定位,倾斜,动画,多背景
            例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</p>
        <h3>8.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3>
        <p>一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
            较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
            采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。
            它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。
            常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
            在布局上有了比以前更加灵活的空间。

            具体：<a href="http://www.w3cplus.com/css3/flexbox-basics.html"target="_blank">http://www.w3cplus.com/css3/flexbox-basics.html</a>
        </p>
        <h3>9.用纯CSS创建一个<span class="red">三角形</span>的原理是什么？</h3>
        <p>把上、左、右三条边隐藏掉（颜色设为 transparent）
            #demo {
            width: 0;
            height: 0;
            border-width: 20px;
            border-style: solid;
            border-color: transparent transparent red transparent;
            }</p>
        <h3>10.一个满屏 品 字布局 如何设计?</h3>
        <p>简单的方式：
            上面的div宽100%，下面的两个div分别宽50%，
            然后用float或者inline使其不换行即可</p>
        <h3>11.css<span class="red">多列等高</span>如何实现？</h3>
        <p>利用padding-bottom|margin-bottom正负值相抵；
            设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，
            当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，
            其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p>
        <h3>12.常见的浏览器问题</h3>
        <p><a href="http://www.qdfuns.com/notes/18090/961a36d50f2efa676061b5a02c374f75.html" target="_blank">47种常见浏览器兼容问题</a></p>
        <h3>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3>
        <p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>
        <h3>13.absolute的containing block(容器块)计算方式跟正常流有什么不同？</h3>
        <p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：
            1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；
            2、否则,则由这个祖先元素的 padding box 构成。
            如果都找不到，则为 initial containing block。

            补充：
            1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）
            2. absolute: 向上找最近的定位为absolute/relative的元素
            3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</p>
        <h3>14.CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</h3>
        <p>可能已经用过visibility上千遍了，最常用的是visible和hidden，用来使元素显示或者隐藏。
            还有第三个很少被用到的值是collapse，除了在表格的行，列中使用有差异外，他和hidden的作用是等同的。
            <a href="http://www.2cto.com/kf/201404/295875.html" target="_blank">相关介绍</a>
        </p>
        <h3>15.css定义的权重</h3>
        <p>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：

            /*权重为1*/
            div{
            }
            /*权重为10*/
            .class1{
            }
            /*权重为100*/
            #id1{
            }
            /*权重为100+1=101*/
            #id1 div{
            }
            /*权重为10+1=11*/
            .class1 div{
            }
            /*权重为10+10+1=21*/
            .class1 .class2 div{
            }

            如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</p>
        <h3>16.zoom:1的清除浮动原理?</h3>
        <p>清除浮动，触发hasLayout；
            Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
            譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。

            来龙去脉大概如下：
            当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

            Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。

            目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
            可以通过css3里面的动画属性scale进行缩放。</p>
        <h3>17.什么是外边距合并？</h3>
        <p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
            合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
            w3school介绍网址： <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank">http://www.w3school.com.cn/css/css_margin_collapsing.asp</a>
        </p>
        <h3>18.CSS优化、提高性能的方法有哪些？</h3>
        <p>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；
            如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；
            提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;
            使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；
        </p>
        <h3><span class="red"> 其他题目：</span></h3>
        <h3>1.在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3>
        <h3>2.<span class="red">抽离样式模块</span>怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h3>
        <h3>3.全屏滚动的原理是什么？用到了CSS的那些属性？</h3>
        <h3>4.如何修改chrome记住密码后自动填充表单的黄色背景 ？</h3>
        <p>input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
            background-color: rgb(250, 255, 189); /* #FAFFBD; */
            background-image: none;
            color: rgb(0, 0, 0);
            }
        </p>
        <h3>5.怎么让Chrome支持小于12px 的文字？</h3>
        <p>1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
            2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。
            3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。
            4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</p>
        <h3>6.让页面里的字体变清晰，变细用CSS怎么做？</h3>
        <p>-webkit-font-smoothing: antialiased;</p>
        <h3>7.position:fixed;在android下无效怎么处理？</h3>
        <p>fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，
            原来的网页还好好的在那，fixed的内容也没有变过位置，
            所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</p>
        <h3>8.display:inline-block 什么时候会显示间隙？(携程)</h3>
        <p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>
        <h3>9.overflow: scroll时不能平滑滚动的问题怎么处理？</h3>
        <h3>10.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3>
        <h3>11.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3>
        <h3>12.什么是<span class="red">Cookie 隔离</span>？（或者说：请求资源的时候不要让它带cookie怎么做）</h3>
        <p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
            所以不如隔离开。

            因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
            这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

            同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，
            提高了webserver的http请求的解析速度。</p>
        <h3>13.style标签写在body后与body前有什么区别？</h3>

        <h2>JavaScript</h2>
        <h3>1.介绍js的基本数据类型。</h3>
        <p> Undefined、Null、Boolean、Number、String、
            ECMAScript 2015 新增:<span class="red">Symbol</span>(创建后独一无二且不可变的数据类型 )</p>
        <h3>2.介绍js有哪些内置对象？</h3>
        <p>Object 是 JavaScript 中所有对象的父对象

            数据封装类对象：Object、Array、Boolean、Number 和 String
            其他对象：Function、Arguments、Math、Date、RegExp、Error

            参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html</p>
        <h3>3.说几条写JavaScript的基本规范？</h3>
        <p>1.不要在同一行声明多个变量。
            2.请使用 ===/!==来比较true/false或者数值
            3.使用对象字面量替代new Array这种形式
            4.<span class="red">*不要使用全局函数。</span>
            5.Switch语句必须带有default分支
            6.函数不应该有时候有返回值，有时候没有返回值。
            7.For循环必须使用大括号
            8.If语句必须使用大括号
            9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染</p>
        <h3>4.JavaScript原型，原型链 ? 有什么特点？</h3>
        <p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
            如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
            于是就这样一直找下去，也就是我们平时所说的原型链的概念。
            关系：instance.constructor.prototype = instance.__proto__

            特点：
            JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。


            当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
            就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。
            function Func(){}
            Func.prototype.name = &quot;Sean&quot;;
            Func.prototype.getInfo = function() {
            return this.name;
            }
            var person = new Func();//现在可以参考var person = Object.create(oldObject);
            console.log(person.getInfo());//它拥有了Func的属性和方法
            //&quot;Sean&quot;
            console.log(Func.prototype);
            // Func { name=&quot;Sean&quot;, getInfo=function()}</p>
        <h3>5.JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3>
        <p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）
            堆：引用数据类型（对象、数组和函数）

            两种类型的区别是：存储位置不同；
            原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
            引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
        <img src="687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966.gif" alt="数据类型内存图">
        <h3>6.如何将字符串转化为数字，例如'12.3b'?</h3>
        <p>* parseFloat(&#x27;12.3b&#x27;);
            * 正则表达式，&#x27;12.3b&#x27;.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</p>
        <h3>7.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</h3>
        <p><code>function commafy(num){
    return num && num
    .toString()
    .replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
        return $2 + ',';
    });
}
            </code>
        </p>
        <h3>8.JavaScript继承的几种实现方式？</h3>
        <p>参考：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank">构造函数的继承</a>，<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">非构造函数的继承</a></p>
        <h3>9.javascript创建对象的几种方式？</h3>
        <p><code>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，
当然还可以用JSON；但写法有很多种，也能混合使用。

1、对象字面量的方式

person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};

2、用function来模拟无参的构造函数

function Person(){}
var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
person.name="Mark";
person.age="25";
person.work=function(){
alert(person.name+" hello...");
}
person.work();

3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

function Pet(name,age,hobby){
this.name=name;//this作用域：当前对象
this.age=age;
this.hobby=hobby;
this.eat=function(){
alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
}
}
var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
maidou.eat();//调用eat方法


4、用工厂方式来创建（内置对象）

var wcDog =new Object();
wcDog.name="旺财";
wcDog.age=3;
wcDog.work=function(){
alert("我是"+wcDog.name+",汪汪汪......");
}
wcDog.work();


5、用原型方式来创建

function Dog(){

}
Dog.prototype.name="旺财";
Dog.prototype.eat=function(){
alert(this.name+"是个吃货");
}
var wangcai =new Dog();
wangcai.eat();


6、用混合方式来创建

function Car(name,price){
this.name=name;
this.price=price;
}
Car.prototype.sell=function(){
alert("我是"+this.name+"，我现在卖"+this.price+"万元");
}
var camry =new Car("凯美瑞",27);
camry.sell(); </code></p>
        <h3>10.eval是做什么的？</h3>
        <p>它的功能是把对应的字符串解析成JS代码并运行；
            应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
            由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');</p>
        <h3>11.Javascript<span class="red">作用链域</span>?</h3>
        <p>this总是指向函数的直接调用者（而非间接调用者）；
            如果有new关键字，this指向new出来的那个对象；
            在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</p>
        <h3>12.写一个通用的事件侦听器函数。</h3>
        <p><code>// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
// 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
    var oldonload = window.onload;
    if (typeof window.onload != 'function') {
        window.onload = fn;
    } else {
        window.onload = function() {
            oldonload();
            fn();
        };
    }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
        //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function() {
                handler.call(element);
            });
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.datachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    },
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
             while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};</code></p>
        <h3>13.事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3>
        <p>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
            2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
            3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</p>
        <h3>14.["1", "2", "3"].map(parseInt) 答案是多少？</h3>
        <p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，
            其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;
            但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。

            function parseInt(str, radix) {
            return str+&#x27;-&#x27;+radix;
            };
            var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];
            a.map(parseInt);  // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix

            因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN
            所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN]

            详细解析：http://blog.csdn.net/justjavac/article/details/19473199</p>
        <h3>15.javascript 代码中的"<span class="red">use strict</span>";是什么意思 ? 使用它区别是什么？</h3>
        <p>use strict是一种ECMAscript 5 添加的（<span class="red">严格</span>）运行模式,这种模式使得 Javascript 在更严格的条件下运行,

            使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
            默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
            全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
            消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;

            提高编译器效率，增加运行速度；
            为未来新版本的Javascript标准化做铺垫</p>
        <h3>16.如何判断一个对象是否属于某个类</h3>
        <p>使用 <span class="red">instanceof</span> （待完善）
            if(a instanceof Person){
            alert('yes');
            }</p>
        <h3>17.用原生JavaScript的实现过什么功能吗？</h3>
        <h3>18.Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3>
        <p>hasOwnProperty

            javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
            使用方法：
            object.hasOwnProperty(proName)
            其中参数object是必选项。一个对象的实例。
            proName是必选项。一个属性名称的字符串值。

            如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</p>
        <h3>19.<code>[].forEach.call($$("*"),function(a){a.style.outline="1px solid #"+(~~(Math.random()*
(1<<24))).toString(16)}) </code>能解释一下这段代码的意思吗？</h3>
        <h3>20.js延迟加载的方式有哪些？</h3>
        <p>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>
        <h3>21.Ajax 是什么? 如何创建一个Ajax</h3>
        <p>ajax的全称：Asynchronous Javascript And XML。
            异步传输+js+xml。
            所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。

            (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
            (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
            (3)设置响应HTTP请求状态变化的函数
            (4)发送HTTP请求
            (5)获取异步调用返回的数据
            (6)使用JavaScript和DOM实现局部刷新</p>
        <h3>22.Ajax 解决浏览器缓存问题？</h3>
        <p>1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。

            2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。

            3、在URL后面加上一个随机数： "fresh=" + Math.random();。

            4、在URL后面加上时间搓："nowtime=" + new Date().getTime();。

            5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</p>
        <h3>23.同步和异步的区别?</h3>
        <p>同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.

            同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。

            异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

            （待完善）</p>
        <h3>24.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别</h3>
        <p>Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。

            区别：

            1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
            2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

            // CMD
            define(function(require, exports, module) {
            var a = require('./a')
            a.doSomething()
            // 此处略去 100 行
            var b = require('./b') // 依赖可以就近书写
            b.doSomething()
            // ...
            })

            // AMD 默认推荐
            define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
            a.doSomething()
            // 此处略去 100 行
            b.doSomething()
            // ...
            })

            AMD 规范在这里：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank">https://github.com/amdjs/amdjs-api/wiki/AMD</a>

            CMD 规范在这里：<a href="https://github.com/seajs/seajs/issues/242" target="_blank">https://github.com/seajs/seajs/issues/242</a>
        </p>
        <h3>25.requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3>
        <p>参考：<a href="http://annn.me/how-to-realize-cmd-loader/" target="_blank">http://annn.me/how-to-realize-cmd-loader/</a></p>
        <h3>26.JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3>
        <h3>27.异步加载JS的方式有哪些？ <span class="red">***</span></h3>
        <p> (1) defer，只支持IE

            (2) async：

            (3) 创建script，插入到DOM中，加载完毕后callBack</p>
        <h3>28.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</h3>
        <p>（1）创建新节点
            createDocumentFragment()    //创建一个DOM片段
            createElement()   //创建一个具体的元素
            createTextNode()   //创建一个文本节点
            （2）添加、移除、替换、插入
            appendChild()
            removeChild()
            replaceChild()
            insertBefore() //在已有的子节点前插入一个新的子节点
            （3）查找
            getElementsByTagName()    //通过标签名称
            getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
            getElementById()    //通过元素Id，唯一性</p>
        <h3>29. .call() 和 .apply() 的区别？</h3>
        <h3>30.如何编写高性能的Javascript？</h3>
        <h3>31.那些操作会造成内存泄漏？</h3>
        <p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
            垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

            setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
            闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>
        <h3>32.jquery.extend 与 jquery.fn.extend的区别？</h3>
        <p>* jquery.extend 为jquery类添加类方法，可以理解为添加静态方法
            * jquery.fn.extend:
            源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数
            使用：
            jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</p>
        <h3>33.谈一下Jquery中的bind(),live(),delegate(),on()的区别？</h3>
        <h3>34.jQuery 的队列是如何实现的？队列可以用在哪些地方？</h3>
        <h3>35.是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</h3>
        <h3>36.Jquery与jQuery UI 有啥区别？</h3>
        <p>*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。

            *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
            提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</p>
        <h3>37.jquery 中如何将数组转化为json字符串，然后再转化回来？</h3>
        <p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展:
        <code>    $.fn.stringifyArray = function(array) {
    return JSON.stringify(array)
}

$.fn.parseArray = function(array) {
    return JSON.parse(array)
}

然后调用：
$("").stringifyArray(array)</code></p>
        <h3>38.针对 jQuery 的优化方法？</h3>
        <p>*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。

            *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
            比如：var str=$("a").attr("href");

            *for (var i = size; i < arr.length; i++) {}
            for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
            for (var i = size, length = arr.length; i < length; i++) {}</p>
        <h3>39.知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout...)么? 能讲出他们各自的优点和缺点么?</h3>
        <h3>40.JQuery一个对象可以同时绑定多个事件，这是如何实现的？</h3>
        <p>* 多个事件同一个函数：
            $("div").on("click mouseover", function(){});
            * 多个事件不同函数
            $("div").on({
            click: function(){},
            mouseover: function(){}
            });</p>
        <h2>大部分内容来源于：</h2>
        <h3><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="">yugasun的git博客</a></h3>
        <h3>里面还有很多内容可以点击参考</h3>

    </div>
</body>
</html>